console.log(`
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⢀⣴⣶⣶⣶⣶⣄⠀⣀⣴⣶⣶⣶⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⣿⣿⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣸⣿⣿⣀⣀⡀⠀⠀⠀⠀⠀⠀⠈⠻⢿⢿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠿⠿⠿⠿⠿⠿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⠆⠠⣿⡿⣿⣿⣿⢿⣿⣦⣴⣿⡿⠿⢿⣿⣷⣄⠀⢾⣿⣿⣿⣿⡿⣿⠆⢸⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠈⢿⣿⣧⠀⠀⠀⠀⣠⣿⡿⠁⠀⣰⣿⡿⠁⠀⠀⠀⠈⠻⣿⣧⡀⠀⠘⣿⡟⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣧⡀⠀⢰⣿⡿⠁⠀⠀⣿⣿⠁⠀⠀⠀⠀⠀⠀⢻⣿⣇⠀⠀⣿⡇⠀⠀⠀⠀⠀⠸⣿⣿⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣷⣴⣿⡟⠀⠀⠀⢰⣿⡟⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⣿⡇⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⡏⠀⠀⠀⠀⠘⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⣿⡇⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡀⠀⠀⠀⠀⠀⣿⣿⡄⠀⠀⠀⠀⠀⠀⣿⣿⠇⠀⠀⣿⣧⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣿⣿⣇⣀⡀ ⠀⠘⢿⣿⣦⣀⠀⢀⣠⣾⣿⠏⠀⠀ ⢿⣿⣦⡀⠀⠀⣀⣼⣿⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠀⠀⠻⠿⠿⠿⠿⠿⠿⠿⠀⠀⠀⠀⠙⠿⢿⣿⣿⠿⠛⠁⠀⠀⠀⠀⠀⠙⠿⢿⣿⣿⡿⠟⠀⠀⠀⠀⠀
    
    
            Hey, you! 👀 Guess what?
                Sppu Codes is open-source
                    and totally free to explore! 🎉
                        Dive in: https://github.com/AlbatrossC/sppu-codes
            ⠀
    `);
    
(function(c, l, a, r, i, t, y) {
    c[a] = c[a] || function() { (c[a].q = c[a].q || []).push(arguments) };
    t = l.createElement(r);
    t.async = 1;
    t.src = "https://www.clarity.ms/tag/" + i;
    y = l.getElementsByTagName(r)[0];
    y.parentNode.insertBefore(t, y);
})(window, document, "clarity", "script", "qnqi8o9y94");

(function () {
    // Function to load Google Tag Manager asynchronously
    function loadGTM() {
        var script = document.createElement('script');
        script.src = 'https://www.googletagmanager.com/gtag/js?id=G-1R5FFVKTF8';
        script.async = true;

        script.onload = function () {
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                window.dataLayer.push(arguments);
            }
            gtag('js', new Date());
            gtag('config', 'G-1R5FFVKTF8');
        };

        document.head.appendChild(script);
    }

    // Function to load Google Fonts asynchronously
    function loadGoogleFonts() {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://fonts.googleapis.com/css2?family=Fira+Code&display=swap';
        link.type = 'text/css';
        document.head.appendChild(link);
    }

    // Function to load marked.js asynchronously with a specific version
    function loadMarkedJS() {
        var script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked@4.0.0/marked.min.js';
        script.async = true;
        document.head.appendChild(script);
    }

    // Load Google Tag Manager after a delay or when needed
    setTimeout(loadGTM, 3000); // Delay GTM loading by 3 seconds

    // Load Google Fonts and marked.js only when needed
    document.addEventListener('DOMContentLoaded', function () {
        loadGoogleFonts();
        loadMarkedJS();
    });
})();

// Modal backdrop setup
const backdrop = document.createElement('div');
backdrop.className = 'modal-backdrop';
document.body.appendChild(backdrop);

// System Instructions
const SYSTEM_INSTRUCTIONS = {
    initial: 'You are an code explanation bot. I will provide you a question for reference and its code. your task is explain it in this format: Prefers code explanations in the following structured format: 1. Understanding the Code – Explanation of key components and their purpose. 2. Main Function Execution Flow – Step-by-step breakdown of how the program runs. 3. Summary – Key features and concepts covered in the code. Note: Break code in several parts and then explain each step in snippet format. Dont write the whole code in the chat. Also note that the explanation should be based on the syllabus of Courses present in SPPU university.',

    followup: 'You are an AI assistant tasked with answering the latest question based on the provided code and conversation history. Focus on the text after "Question:" as the main prompt, ignoring older questions unless directly relevant. Use the conversation history purely for context, and simplify your response when asked a follow up question. (it maybe related to the code and it can be random) by avoiding technical jargon and making it beginner-friendly. If code is provided, break it into smaller parts and explain each step-by-step, but do not repeat the entire code unless explicitly requested. Now, answer the latest question based on the following:'
};

// Conversation memory (supports up to 2 million tokens)
let conversationMemory = [];

// Function to fetch explanation from server-side endpoint
async function fetchExplanation(instruction, question, codeText = '') {
    const requestBody = {
        instruction,
        question,
        codeText
    };

    try {
        const response = await fetch('/api/explain-code', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! Status: ${response.status}. Details: ${errorText}`);
        }

        const data = await response.json();
        const responseText = data.explanation;

        // Store the response in conversation memory
        conversationMemory.push(`You: ${question}`);
        conversationMemory.push(`Bot: ${responseText}`);
        
        return responseText;
    } catch (error) {
        throw error;
    }
}

// Function to load a file dynamically
async function loadFile(subject, fileName, questionText, element) {
    console.log(`Loading file: ${subject}/${fileName}`);

    const questionItem = element.closest('.question-item');
    if (!questionItem) {
        return;
    }

    const answerBox = questionItem.querySelector('.answer-box');
    if (!answerBox) {
        return;
    }

    const questionId = answerBox.id.match(/\d+[a-z]?/)?.[0];
    if (!questionId) {
        return;
    }

    const questionTitle = document.getElementById('questionText' + questionId);
    const codeContent = document.getElementById('codeContent' + questionId);

    if (!questionTitle || !codeContent) {
        return;
    }

    // Show loading state
    codeContent.innerText = 'Loading...';
    answerBox.style.display = 'block';
    backdrop.style.display = 'block';
    document.body.style.overflow = 'hidden';

    // Ensure modal content wrapper exists
    if (!answerBox.querySelector('.modal-content')) {
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        while (answerBox.children.length > 0) {
            modalContent.appendChild(answerBox.children[0]);
        }
        answerBox.appendChild(modalContent);
    }

    try {
        const response = await fetch(`/answers/${subject}/${fileName}`);
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.text();
        
        questionTitle.innerText = questionText;
        codeContent.innerText = data;
    } catch (err) {
        codeContent.innerText = `Error loading file: ${err.message}`;
        alert(`Failed to load ${fileName}. Error: ${err.message}`);
    }
}

// Function to copy code to clipboard
function copyCode(elementId) {
    const codeElement = document.getElementById(elementId);
    if (!codeElement) return;
    
    const codeText = codeElement.innerText;
    const copyButton = document.querySelector(`#${elementId}`).parentElement.querySelector('.copy-btn');
    if (!copyButton) return;

    navigator.clipboard.writeText(codeText)
        .then(() => {
            copyButton.classList.add('copied');
            copyButton.innerHTML = 'Copied to Clipboard';
            setTimeout(() => {
                copyButton.classList.remove('copied');
                copyButton.innerHTML = 'Copy Code';
            }, 2000);
        })
        .catch(err => {
            alert('Failed to copy code! Please try selecting and copying manually.');
        });
}

// Function to close modal boxes
function closeBox(boxId) {
    const box = document.getElementById(boxId);
    if (box) {
        box.classList.remove('split-view');
        box.style.display = 'none';
        backdrop.style.display = 'none';
        document.body.style.overflow = 'auto';
    }
}

// Function to close the explanation modal and reset everything
function closeExplanationModal() {
    const explanationModal = document.getElementById('explanationModal');
    if (!explanationModal) return;
    
    // Reset the modal
    explanationModal.classList.remove('split-view');
    explanationModal.style.display = 'none';
    
    // Check if the answer box is still visible
    const answerBox = document.querySelector('.answer-box[style*="display: block"]');
    if (answerBox) {
        // If the answer box is still visible, show the backdrop
        backdrop.style.display = 'block';
    } else {
        // If no answer box is visible, hide the backdrop
        backdrop.style.display = 'none';
        document.body.style.overflow = 'auto';
    }

    // Reset the original answer box
    if (answerBox) {
        answerBox.classList.remove('split-view');
        answerBox.style.left = '50%';
        answerBox.style.transform = 'translate(-50%, -50%)';
        answerBox.style.width = '90%';
        answerBox.style.maxWidth = '1200px';
        answerBox.style.height = 'auto';
        answerBox.style.borderRadius = '12px';
    }

    // Clear conversation memory
    conversationMemory = [];

    // Clear the messages container
    const messagesContainer = document.getElementById('messagesContainer');
    if (messagesContainer) {
        messagesContainer.innerHTML = '';
    }
}

// Helper function to create explanation modal if it doesn't exist
function createExplanationModal() {
    let explanationModal = document.getElementById('explanationModal');
    
    if (!explanationModal) {
        explanationModal = document.createElement('div');
        explanationModal.id = 'explanationModal';
        explanationModal.className = 'explanation-modal';
        explanationModal.innerHTML = `
            <div class="modal-content">
                <h3>Code Explanation</h3>
                <div id="messagesContainer" class="messages-container"></div>
                <div class="sticky-bottom">
                    <input type="text" id="furtherQuestionInput" placeholder="Ask a further question about this code...">
                    <button id="askFurtherQuestionBtn">Ask</button>
                    <button class="close-btn" onclick="closeExplanationModal()">Close</button>
                </div>
            </div>
        `;
        document.body.appendChild(explanationModal);

        // Add event listener for asking further questions
        document.getElementById('askFurtherQuestionBtn').addEventListener('click', handleFurtherQuestion);

        // Add event listener for Enter key in input field
        const input = document.getElementById('furtherQuestionInput');
        input.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                handleFurtherQuestion();
            }
        });
    }
    
    return explanationModal;
}

// Function to handle further questions
async function handleFurtherQuestion() {
    const input = document.getElementById('furtherQuestionInput');
    const question = input.value.trim();
    if (!question) return;
    
    const codeElement = document.querySelector('.answer-box[style*="display: block"] .code-content');
    const codeText = codeElement ? codeElement.innerText : '';
    const messagesContainer = document.getElementById('messagesContainer');
    
    // Add user question to messages
    messagesContainer.innerHTML += `<div class="message user-message">You: ${question}</div>`;
    
    // Add loading message
    const loadingMsgId = `loading-${Date.now()}`;
    messagesContainer.innerHTML += `<div id="${loadingMsgId}" class="message bot-message">Bot: Processing your question...</div>`;
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    try {
        const response = await fetchExplanation(SYSTEM_INSTRUCTIONS.followup, question, codeText);
        const markdownResponse = marked.parse(response);
        
        const loadingMsg = document.getElementById(loadingMsgId);
        if (loadingMsg) {
            loadingMsg.innerHTML = `Bot: ${markdownResponse}`;
        }
        
        // Store the conversation in memory
        conversationMemory.push(`You: ${question}`);
        conversationMemory.push(`Bot: ${response}`);
    } catch (error) {
        const loadingMsg = document.getElementById(loadingMsgId);
        if (loadingMsg) {
            loadingMsg.innerHTML = `Bot: Error: ${error.message}`;
        }
    }
    
    input.value = '';
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Function to explain code using server-side endpoint
async function explainCode(elementId) {
    const codeElement = document.getElementById(elementId);
    if (!codeElement) return;
    
    const codeText = codeElement.innerText;
    const questionItem = codeElement.closest('.question-item');
    const questionText = questionItem?.querySelector('h1')?.innerText || 'Code analysis';
    
    // Create or get explanation modal
    const explanationModal = createExplanationModal();
    const messagesContainer = document.getElementById('messagesContainer');
    
    // Add loading animation
    messagesContainer.innerHTML = `
        <div class="message bot-message">
            <div class="loading-container">
                <p>Bot: Analyzing code and preparing explanation</p>
                <div class="loading-animation">
                    <div class="dot dot1"></div>
                    <div class="dot dot2"></div>
                    <div class="dot dot3"></div>
                </div>
            </div>
        </div>
    `;
    
    // Reset styles for split view
    const answerBox = codeElement.closest('.answer-box');
    if (answerBox) {
        answerBox.classList.add('split-view');
        answerBox.style.left = '0';
        answerBox.style.transform = 'translateY(-50%)';
        answerBox.style.width = 'calc(50% - 10px)';
        answerBox.style.maxWidth = 'none';
        answerBox.style.height = '100vh';
        answerBox.style.borderRadius = '12px';
        answerBox.style.marginRight = '10px';
    }

    if (explanationModal) {
        explanationModal.classList.add('split-view');
        explanationModal.style.display = 'block';
        explanationModal.style.width = 'calc(50% - 10px)';
        explanationModal.style.left = 'calc(50% + 10px)';
        explanationModal.style.transform = 'translateY(-50%)';
    }

    backdrop.style.display = 'block';
    document.body.style.overflow = 'hidden';

    try {
        const explanation = await fetchExplanation(SYSTEM_INSTRUCTIONS.initial, questionText, codeText);
        const markdownExplanation = marked.parse(explanation);
        
        // Clear loading message
        messagesContainer.innerHTML = '';
        
        // Create a new message for the bot's response
        const botMessage = document.createElement('div');
        botMessage.className = 'message bot-message';
        botMessage.innerHTML = `Bot: ${markdownExplanation}`;
        messagesContainer.appendChild(botMessage);
        
        // Store the initial explanation in memory
        conversationMemory.push(`Bot: ${explanation}`);
    } catch (error) {
        messagesContainer.innerHTML = `
            <div class="message bot-message">
                Bot: Error: Unable to fetch explanation. ${error.message}
                <div class="error-help">
                    <p>This might be due to:</p>
                    <ul>
                        <li>Network connectivity issues</li>
                        <li>Server-side errors</li>
                    </ul>
                </div>
            </div>
        `;
    }

    // Scroll to the bottom of the messages container
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Helper function to escape HTML
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

// Function to download code
async function downloadCode(subject, fileName) {
    try {
        const response = await fetch(`/answers/${subject}/${fileName}`);
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.text();
        
        const blob = new Blob([data], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    } catch (err) {
        alert(`Failed to download ${fileName}. Error: ${err.message}`);
    }
}

// Event: Close modal or popup with Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        const popup = document.getElementById('dynamicCopyPopup');
        if (popup && popup.style.display === 'flex') {
            closePopup();
        } else {
            const visibleModal = document.querySelector('.answer-box[style*="display: block"]');
            if (visibleModal) {
                closeBox(visibleModal.id);
            }
            const explanationModal = document.getElementById('explanationModal');
            if (explanationModal && explanationModal.style.display === 'block') {
                closeExplanationModal();
            }
        }
    }
});

// Close modals by clicking on backdrop
backdrop.addEventListener('click', function() {
    const visibleModal = document.querySelector('.answer-box[style*="display: block"]');
    if (visibleModal) {
        closeBox(visibleModal.id);
    }
    const explanationModal = document.getElementById('explanationModal');
    if (explanationModal && explanationModal.style.display === 'block') {
        closeExplanationModal();
    }
});

// Add responsive handlers for window resizing
window.addEventListener('resize', () => {
    const explanationModal = document.getElementById('explanationModal');
    const visibleAnswerBox = document.querySelector('.answer-box[style*="display: block"]');
    
    if (explanationModal && explanationModal.style.display === 'block' && visibleAnswerBox) {
        if (window.innerWidth < 768) {
            // On small screens, disable split view
            explanationModal.classList.remove('split-view');
            visibleAnswerBox.classList.remove('split-view');
            explanationModal.style.width = '90%';
            visibleAnswerBox.style.width = '90%';
        } else {
            // On larger screens, enable split view
            explanationModal.classList.add('split-view');
            visibleAnswerBox.classList.add('split-view');
        }
    }
});